

# Playlist.py







[Playlist Function Based On This Link](https://www.linkedin.com/pulse/extracting-your-fav-playlist-info-spotifys-api-samantha-jones/)







The above link is the basis for the call_playlist function. I decided to store this function in a different document to not make app.py super long. First, I set up the tools needed to work with the Spotify API, such as client secret and client ID.







The function takes two arguments, creator and playlist link. The function works regardless of the input for the creator, so in App.py, whenever I called this function, I hard-coded a blank username (“”) and got the link from forms on my website. I did this so I would be prompting the user for less information to achieve the same result.







In the function, which, again, is based heavily on the source above, I create a list of features I want to include in the data frame generated by this function. Next, I create playlist_df, a pandass dataframe, using this list as the column name.







Next, I use Spotipy’s user_playlist_track function to get data from the playlist. This function has a default limit of 100, so I used code from [here](https://stackoverflow.com/questions/55690063/is-there-a-method-to-retrieve-all-tracks-from-a-playlist-using-spotipy) to loop over the entire playlist, not just the first 100 songs. In the loop, it keeps going until it hits the end of the playlist and adds track info to the dataframe.







Then, I loop through every song again and pull data about the song, such as the artist, etc. I first create an empty dictonary and store the data there.







Then, to get most of the numerical audio feature data, I use the audio_features function from Spotify and loop through the audio features in my list created earlier. Then, I concatenate all this information into a dataframe. Also, I wanted to get the date and decade of each song, so I used to_datatime and dt.year to convert the release date to just the year of release. Then, I rounded each year down to the nearest decade and cast it as an integer (to make it easier to graph). I did this rounding by dividing the yera by 10, taking the floor of it, and then multiplying by 10. This got me the decade of release.







I also created bins and labels for each bin. Bins allowed me to group together data that were in the same range, for example, allowing me to group songs with a tempo between 40 and 50. I looped through the features that had data reported in ranges from 0 to 1, and used pd.cut to sort the numbers into the bins. I then added this information to the dataframe as a column. Then, I did the same for tempo, which can be above 0. I grouped together tempos between 200 and 100000 as 200+. You will never see a song with a tempo as high as 100000, but I included it as an upper limit, just in case.







Then, I converted millisecond song length data to seconds and then minutes, and created bins for songs with similar lengths.







Then, I changed mode (which Spotify reports as 0 for minor, and 1 for major) from 0 to minor and 1 to major. This allowed me to display data in a way the user could understand instead of an indicator variable.







Lastly, I read Spotify’s API and changed numbers representing different keys to the keys they actually represented; and returned the final dataframe.







# App.py







In App.Py, the first thing I did was set up the flask app, as well as the things needed to work w/ the Spotify API; Namely, a client ID, secret, and redirect URI; as well as environment variables for each. I used os.urandom(16) to generate a secret key of random bytes.







Under @app.route('/'), using [this](https://github.com/spotipy-dev/spotipy/blob/master/examples/app.py), I created the route for the index page. Here, I store information about the current user’s session. Also, I prompt a sign in using Spotify’s website (by using spotipy.oauth2). Logging in gives users a token. If a user is signed in, I store their Spotify display name and display it on the index page. If the user is not signed in, I prompt them to sign in, in order to get a usable token.







Under @app.route('/sign_out), using the same source as above, I borrow the sign out feature, which removes the token, and returns the user to the index.







Under @app.route('/nav'), I use the same source as above to prompt users to sign in if they are not signed in. If the user is signed in, I request a playlist link (and return text indicating an error if the format of user input isn’t correct). I then call the call_playlist function, which creates a dataframe of the playlist data. I then set the link and dataframe as session variables, to pass it through to other routes. Also, storing the data frame as a session variable makes the site much faster, since I don’t have to use call_playlist every time I navigate to a new page of the site, I can just use this session info.







The rest of the routes follow the same format. For each, I check if the user is logged in, and redirect to the sign in page if not. Also, I pull the data frame from the session, and make the graphs. Using [this](https://kenneho.net/2021/07/11/plotly-without-dash/) for guidance, I create HTML for the graphs that I pass through to the html files w/ Jinja. Using plotly express, I make bar charts and pie charts. For the bar charts, I use value_counts to count how many songs fall into each bin (ex. How many songs are between 1 and 2 mins long, etc.) and then normalize them (times 100) to get the percentage of songs in each bin. I decided to use a bar chart and group by bins as I thought it would be better for user understanding.







For most of the audio features/graph routes, I use .update_xaxes in order to fix the order of the bar charts. I do this to ensure that the lowest numbers are displayed on the left. Without this, the bar chart would be ordered from highest percentage to lowest. For example, if most songs in the playlist were 10+ mins long, 10+ min would be the first bar. This would be confusing for the user, so I hard-coded the order of the bins to be from lowest value to highest.







Lastly, I wanted to display the raw data in case users wanted to see it. I used .to_html to generate the html for the data frame of user playlist songs and passed it through to the html. I also included some data I chose not to graph, such as artist, album, and release date. For these, graphs wouldn’t be useful to the user since there are many different artists, albums, and release dates of songs in playlists.